// evaluation.wppl
//
// Code for evaluating various types of models
//

// evaluation_modelDistLL
//
// modelDist : model function that takes data inputs and produces distributions
// D : (input, output) pairs over which to apply modelDist and compute log-likelihood
//
// return log-likelihood of data in D according to modelDist model
var evaluation_modelDistLL = function(modelDist, D) {
    return sum(map(function(d) { return modelDist(d.input).score(d.output) }, D));
};

// evaluation_modelEncModeAccuracy
//
// model : encoder/decoder model represented by code in enc.wppl
// D : data set containing (input,output) datums
// distributionFn : function that takes encoder/decoder model output
// and produces a distribution
//
// return accuracy on data in D for encoder/decoder model
// with distributions constructed through distributionFn
var evaluation_modelEncModeAccuracy = function(model, D, distributionFn) {
    var makeInfoKey = function(d) { return (d.info) ? _.join(_.values(d.info), ".") : undefined };

    var correctIndicators = map(function(d) {
        var modes = enc_modelModes(model, d.input, distributionFn);
        var correct = any(function(mode) { mode === d.output.toString() }, modes) ? 1.0 : 0.0 ;

        return { key : makeInfoKey(d), value : correct }
    }, D);

    var aggs = gameppl.util.aggregateKeyValuePairs(correctIndicators);

    return mapObject(function(agg, aggIndicators) {
        return {
            acc : listMean(aggIndicators)
        };
    }, aggs);
};

// evaluation_modelEncLL
//
// model : encoder/decoder model represented by code in enc.wppl
// D : data set containing (input,output) datums
// distributionFn : function that takes encoder/decoder model output
// and produces a distribution
//
// return log-likelihood of data in D according to encoder/decoder model
// with distributions constructed through distributionFn
var evaluation_modelEncLL = function(model, D, distributionFn) {
    var makeInfoKey = function(d) { return (d.info) ? _.join(_.values(d.info), ".") : undefined };

    var lls = map(function(d) { return { key : makeInfoKey(d), value : enc_modelLL(model, d.output, d.input, distributionFn) } }, D);
    var aggs = gameppl.util.aggregateKeyValuePairs(lls);
    return mapObject(function(agg, agglls) {
        return {
            ll: listMean(map(function (ll) {
                ll !== -Infinity && ll !== undefined ? ll : 0.0
            }, agglls)),
            neg: listMean(map(function (ll) {
                ll === -Infinity ? 1.0 : 0.0
            }, agglls)),
            undef: listMean(map(function (ll) {
                ll === undefined ? 1.0 : 0.0
            }, agglls))
        };
    }, aggs);
};

// evaluation_modelEncEvalFlattened
//
// evals : Evaluations output from evaluation_modelEncLL
// [maybePrefix] : Optional prefix for key strings
//
// return [list of keys, list of values]
var evaluation_modelEncEvalFlattened = function(evals, maybePrefix) {
    var keyValuePairs = _.flatten(_.values(mapObject(function(key, innerObj) {
        return _.values(mapObject(function(innerKey, innerValue) {
            if (maybePrefix)
                return [maybePrefix + "." + key + "." + innerKey, innerValue];
            else
                return [key + "." + innerKey, innerValue];
        }, innerObj))
    }, evals)));
    
    return _.unzip(sort(keyValuePairs, lt, function(kvPair) { return kvPair[0] }));
};
