var NN_DECODER_SIGMOID = 0;
var NN_DECODER_LINEAR = 1;
var NN_DECODER_SOFTMAX = 2;

var NN_ENCODER_TANH = 0;
var NN_ENCODER_CONSTANT = 1;

var NN_SEQUENCE_STEP_LSTM = 0;

var _nn_makeModelParam = function(name, maybeDims) {
    guide(function () {
        globalStore['nnParams_' + name] = param({ name : 'nnParams_' + name, dims : maybeDims });
    });
    return globalStore['nnParams_' + name];
}

// _nn_makeState
//
// params:
//   name : Reference name
//   dimension : Dimension of state
var _nn_makeState = function(params) {
    return _nn_makeModelParam("state_" + params.name,  [params.dimension, 1]);
};


// nn_initEncoder
//
// params:
//   name : Reference name
//   encoderType : (NN_ENCODER_TANH, NN_ENCODER_CONSTANT)
//   inputDimension : Dimension of the input
//   latentDimension : Dimension of hidden state
var nn_initEncoder = function(params) {
    if (params.encoderType === NN_ENCODER_TANH) {
        return stack([
            tanh,
            bias("enc_bias_0_" + params.name, { out : params.latentDimension, param : modelParam }),
            affine('enc_layer_0_' + params.name, { in : params.inputDimension, out : params.latentDimension, param : modelParam })
        ]);
    } else if (params.encoderType == NN_ENCODER_CONSTANT) {
        var initialState = _nn_makeState({ name : params.name, dimension : params.latentDimension });
        return function() { return initialState };
    }
};

// nn_applyEncoder
//
// encoder : encoder initialized by nn_initEncoder
// input : Input to the encoder
var nn_applyEncoder = function(encoder, input) {
    return encoder(input);
}

// nn_initDecoder
//
// params:
//   name : Reference name
//   decoderType : Activation function at output later (NN_DECODER_SIGMOID, NN_DECODER_LINEAR, NN_DECODER_SOFTMAX)
//   latentDimension : Dimension of latent input
//   outputDimension : Dimension of output later
var nn_initDecoder = function(params) {
    if (params.decoderType == NN_DECODER_SIGMOID) {
        return stack([
            sigmoid,
            affine('dec_layer_0_' + params.name, { in : params.latentDimension, out : params.outputDimension, param : modelParam })
        ]);
    } else if (params.decoderType == NN_DECODER_LINEAR) {
        return stack([
            affine('dec_layer_0_' + params.name, { in : params.latentDimension, out : params.outputDimension, param : modelParam })
        ]);
    } else if (params.decoderType == NN_DECODER_SOFTMAX) {
        return stack([
            softmax,
            affine('dec_layer_0_' + params.name, { in : params.latentDimension, out : params.outputDimension, param : modelParam })
        ]);
    }
};

// nn_applyDecoder
//
// decoder : decoder initialized by nn_initDecoder
// input : observed input (probably passed through encoder to construct state)
// latentState : state output by an encoder
var nn_applyDecoder = function(decoder, input, latentState) {
    return decoder(latentState);
};

// nn_decodeDistribution
//
// decoder : decoder initialized by nn_initDecoder
// input : observed input (probably passed through encoder to construct state)
// latentState : State to decode
// distributionFn : decoder output, input, decoder -> Distribution
//
// Return distribution object constructed from decoder
var nn_decodeDistribution = function(decoder, input, latentState, distributionFn) {
    return distributionFn(nn_applyDecoder(decoder, input, latentState), input, decoder);
};

// nn_decodeSample
//
// decoder : decoder initialized by nn_initDecoder
// input : observed input (probably passed through encoder to construct state)
// latentState : state to decode
// distributionFn : decoder output, input, decoder -> Distribution
// [maybeObservation] : Observation to factor on
//
// Return sample from distribution given maybeObservation
var nn_decodeSample = function(decoder, input, latentState, distributionFn, maybeObservation) {
    var Dist = nn_decodeDistribution(decoder, latentState, distributionFn);
    return util_observeHelper(Dist, maybeObservation);
};

// nn_initSequenceEncoderStep
//
// params:
//   name : Reference name
//   latentDimension : Dimension of hidden state (must be even)
//   inputDimension : Dimension of the input
var nn_initSequenceEncoderStep = function(params) {
    assert.ok(params.latentDimension % 2 === 0, 'Dimension for sequence model expected to be even');
    var stepType = params.maybeStepType || NN_SEQUENCE_STEP_LSTM; // Unused for now
    var enc_net = lstm('seq_enc_h_0_' + params.name, { hdim : params.latentDimension, xdim : params.inputDimension, param : modelParam });
    return function(prevState, x) {
        assert.ok(dims(prevState)[0] === params.latentDimension, 'Previous hidden vector has unexpected dimension');
        var x_v = oneHot(x, params.inputDimension);
        var nextState = enc_net(prevState, x_v);
        return nextState;
    };
};

// nn_initSequenceDecoderStep
//
// params:
//   name : Reference name
//   latentDimension : Dimension of hidden state (must be even)
//   outputDimension : Dimension of output
var nn_initSequenceDecoderStep = function(params) {
    assert.ok(params.latentDimension % 2 === 0, 'Dimension for sequence model expected to be even');
    var stepType = params.maybeStepType || NN_SEQUENCE_STEP_LSTM; // Unused for now
    var dec_net_h = lstm('seq_dec_layer_0_' + params.name, { hdim : params.latentDimension, xdim : params.outputDimension, param : modelParam });
    var dec_net_out = stack([softmax, affine('seq_dec_out' + params.name, { in : params.latentDimension + params.outputDimension, out : params.outputDimension, param : modelParam }), concat]);
    return function(state, xs_prev) {
        assert.ok(dims(state)[0] === params.latentDimension, 'Previous hidden vector has unexpected dimension');
        var v = oneHot(xs_prev[xs_prev.length - 1], params.outputDimension);
        var nextState = dec_net_h(state, v);
        var ps = dec_net_out([nextState, v]);
        var pOut = (ps.x === undefined) ? ps.toFlatArray() : ps.x.toFlatArray(); // FIXME Bad
        var outputs = mapIndexed(function(value, score) { return { value : value, score : score } }, pOut);
        return { outputs : outputs, state: nextState }
    };
};
