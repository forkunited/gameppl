// data.wppl
//
// Functions for constructing data sets to train models
//

// Data types that can be inputs/outputs for learning models
const DATA_TYPE_VECTOR_SEQUENCE = 0;
const DATA_TYPE_SCALAR_SEQUENCE = 1;
const DATA_TYPE_VECTOR = 2;
const DATA_TYPE_SCALAR = 3;
const DATA_TYPE_LIST = 4;

// data_makeInputProduct
//
// distribution : function that takes arguments and outputs a distribution
// samplesPerInput : number of samples per input arguments for distribution
// [args...] : Argument lists from which to construct cartesian product
//             input to distribution function
//
// return a list of datums (input, output) generated by distribution function
// applied to each argument tuple samplesPerInput times
var data_makeInputProduct = function(distribution, samplesPerInput) {
	var args = _.rest(arguments, 2);
	return util_mapProductArgs(function() {
		var args = arguments;
		var dist = util_applyFn(distribution, args);
		return repeat(samplesPerInput, function() {
			var input = _.clone(args);
			var output = sample(dist);
			return { input : input, output: output };
		});
	}, args);
};

// data_makeInputProduct
//
// distribution : function that takes arguments and outputs a distribution
// samplesPerInput : number of samples per input arguments for distribution
// [args...] : Argument lists from which to construct tuple
//             inputs to distribution function
//
// return a list of datums (input, output) generated by distribution function
// applied to each argument tuple samplesPerInput times
var data_makeInputTuple = function(distribution, samplesPerInput) {
    var args = _.rest(arguments, 2);
    return util_mapTupleArgs(function() {
        var args = arguments;
        var dist = util_applyFn(distribution, args);
        return repeat(samplesPerInput, function() {
            var input = _.clone(args);
            var output = sample(dist);
            return { input : input, output: output };
        });
    }, args);
};

// data_make
//
// distribution : function that takes arguments and outputs a distribution
// samplesPerInput : number of samples per input arguments for distribution
// inputs : List of arguments for distribution function
//
// return a list of datums (input, output) generated by distribution function
// applied to each argument samplesPerInput times
var data_make = function(distribution, samplesPerInput, inputs) {
	return _.flatten(
		map(function(input) {
			var dist = distribution(input);
			return repeat(samplesPerInput, function() {
				return {input: input, output: sample(dist)}
			});
		},
		inputs),
		/* shallow */ true);

};

// data_makeFromFeatureMatrices
//
// inputF : input feature matrix constructed from src/js/feature.js
// outputF : output feature matrix constructed from src/js/feature.js
// params :
//    maxSequenceLength : Maximum length of vector or scalar sequences.
//                        Sequences exceeding this length will be filtered
//                        from the data
//    inputType : Data type of inputs (DATA_TYPE_VECTOR, DATA_TYPE_SCALAR, etc)
//    outputType : Data type of outputs (DATA_TYPE_VECTOR, DATA_TYPE_SCALAR, etc)
//
// return a list of datums (input, output) constructed from feature
// matrices in inputF and outputF
var data_makeFromFeatureMatrices = function(inputF, outputF, params) {
    var getDataByType = function(vectorSequence, dataType) {
        if (dataType == DATA_TYPE_VECTOR) {
            return vectorSequence[0];
        } else if (dataType == DATA_TYPE_SCALAR) {
        	return ad.value(T.toScalars(vectorSequence[0])[0]);
        } else if (dataType == DATA_TYPE_SCALAR_SEQUENCE) {
        	return (params.maxSequenceLength === undefined || vectorSequence.length <= params.maxSequenceLength) ?
				map(function(v) { ad.value(T.toScalars(v)[0]) }, vectorSequence) : undefined;
        } else if (dataType == DATA_TYPE_VECTOR_SEQUENCE) {
            return (params.maxSequenceLength === undefined || vectorSequence.length <= params.maxSequenceLength) ?
				vectorSequence : undefined;
        }
    }

    var outputD = gameppl.feature.getFeatureMatrixData(outputF);
	var D = _.values(mapObject(function(id, inputf) {
		var outputf = outputD[id];
		var inputMat = gameppl.feature.getFeatureMatrixFromDatum(inputf);
		var outputMat = gameppl.feature.getFeatureMatrixFromDatum(outputf);

        // FIXME Hack for now since tensors in js may be different from tensors in wppl?
        var inputTensorsTemp = gameppl.matrix.matrixToRowTensorList(inputMat);
        var inputTensors = map(function(t) { Vector(t.toFlatArray()) }, inputTensorsTemp);
		var outputTensorsTemp = gameppl.matrix.matrixToRowTensorList(outputMat);
		var outputTensors = map(function(t) { Vector(t.toFlatArray()) }, outputTensorsTemp);

		var input = getDataByType(inputTensors, params.inputType);
        var output = getDataByType(outputTensors, params.outputType);

		return {
			id : id,
			game : gameppl.feature.getGameFromDatum(outputf),
			round : gameppl.feature.getRoundFromDatum(outputf),
            info : gameppl.feature.getInfoFromDatum(outputf),
			input : input,
			output : output };
	}, gameppl.feature.getFeatureMatrixData(inputF)));

	// Filter undefined inputs and outputs (that happen when a sequence exceeds max length)
	return filter(function(d) { d.input !== undefined && d.output !== undefined }, D);
};

// data_splitOnKey
//
// D : data set of (key, input,output) datums constructed by one of the other functions in
//     this data.wppl
// portion : Fraction of data to include in first part of split
// key : key on which to split the data (datums which have the same value for the key will be
//       in the same part of the split
//
// return a pair containing the first part and the second part of the data split
var data_splitOnKey = function(D, portion, key) {
	var keyValues = _.uniq(map(function(d) { return d[key];  }, D));
    var splitPartKeys = util_randomSubset(keyValues, Math.floor(portion*keyValues.length), false);
	var splitPartKeysObj = gameppl.util.makeObject(map(function(k) { return [k, 1]}, splitPartKeys));

    var splitPart0 = filter(function(d) { return _.has(splitPartKeysObj, d[key]) }, D);
    var splitPart1 = filter(function(d) { return !_.has(splitPartKeysObj, d[key]) }, D);

    return [splitPart0, splitPart1];
};


