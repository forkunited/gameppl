var observeHelper = function(dist, val) {
    if (val !== undefined) {
        factor(dist.score(val));
        return val;
    } else {
        return sample(dist, {
            guide: function() {
                return dist; // prevent auto-guide in Forward; always use model dist
            }
        });
    }
};

var initLearningModel = function() {
	// Model form
	// Output distribution
}

var initSequenceInputLearningModel = function() {
	// Encoder step
	// Decoder form
	// Output distribution
}

var initSequenceOutputLearningModel = function() {
    // Encoder form
    // Decoder step
	//
    // Output distribution
}

var makeTrainingObj = function(model, parameterPrior, params) {
	return function(data) {
		return function() {
			var parameters = parameterPrior();
			var modelInstance = model(parameters);
		
			if (data) {
				mapData({ data: data, batchSize : params.batchSize}, function(datum) {
					if (params.modelObserves)
						applyFn(modelInstance, _.union([datum.input], [datum.output]))
					else {
                        var dist = (params.inputType == DATA_TYPE_SEQUENCE) ? modelInstance(datum.input) : applyFn(modelInstance, datum.input);

                        //console.log(dist);
                        //console.log(datum.output);

						factor(dist.score(datum.output));
					}
				});
			}

			return [modelInstance, parameters]; //return modelInstance;
		}
	}
}

var train = function(trainingObj, data, iterations, gradientSamples) {
	var trainingResults = Optimize(trainingObj(data),
			{
				steps: iterations,
				estimator : { ELBO : { samples : gradientSamples }},
			});
	return sample(SampleGuide(trainingObj(), { params: trainingResults }));
}

